1Ô∏è‚É£ Conceptual Overview
Server-Sent Events (SSE)

A unidirectional streaming mechanism over HTTP where:

Client opens a long-lived HTTP connection

Server continuously pushes text events

Built on top of standard HTTP

Browser API: EventSource

Think:

‚ÄúHTTP response that never ends.‚Äù

WebSockets

A full-duplex communication protocol that:

Starts as HTTP

Upgrades via 101 Switching Protocols

Becomes a persistent bidirectional TCP connection

Think:

‚ÄúPersistent TCP socket exposed to the browser.‚Äù

2Ô∏è‚É£ Protocol-Level Differences
üîπ SSE

Protocol: HTTP/1.1 or HTTP/2

Content-Type: text/event-stream

Text-based only

Server ‚Üí Client only

Automatic reconnection

Built-in event ID tracking

Message format:

event: update
data: {"price": 101.2}
id: 42


üîπ WebSockets

Protocol: ws:// or wss://

Upgrades from HTTP

Frame-based protocol

Supports:

Text frames

Binary frames

Full duplex

Custom ping/pong control frames

Frame example:

FIN | OPCODE | MASK | PAYLOAD

3Ô∏è‚É£ Connection Lifecycle Comparison
Step	SSE	WebSocket
Initial handshake	HTTP GET	HTTP GET + Upgrade
Persistent connection	Yes	Yes
Reconnection	Automatic	Manual
Keepalive	Server comment :	Ping/Pong frames
4Ô∏è‚É£ Latency & Throughput
Latency

WebSockets generally lower framing overhead.

SSE includes HTTP chunking.

WebSocket frames are smaller.

In high-frequency systems:

WebSockets outperform SSE.

Throughput

SSE:

Text only

More overhead per message

Poor for bursty high-frequency data

WebSockets:

Binary supported

Efficient framing

Better for high message volume

Interview insight:

If you're streaming thousands of updates per second ‚Üí WebSockets.

5Ô∏è‚É£ Scaling Considerations (Very Important for Interviews)

Both create long-lived connections.

üîπ Problem: Connection Fanout

If 1M users connect:

You now maintain 1M open sockets.

This affects:

Memory

File descriptors

Kernel limits

Load balancer configuration

SSE Scaling Challenges

HTTP connection limits per browser (~6 per domain in HTTP/1.1)

Reverse proxy buffering issues

Less flexible backpressure control

More overhead under high throughput

WebSocket Scaling Challenges

Sticky sessions often required

Need distributed pub/sub

Harder to load balance

Typical production solution:

Client
  ‚Üì
Load Balancer
  ‚Üì
WebSocket Servers
  ‚Üì
Redis / Kafka PubSub
  ‚Üì
Backend services


Both SSE and WebSockets need a message broker at scale.

6Ô∏è‚É£ Backpressure Handling
SSE

Limited control.
If client is slow:

Server buffer grows

Risk of memory pressure

Less fine-grained control.

WebSockets

Better backpressure handling:

Can monitor send buffer

Can apply flow control

More flexible buffering strategies

Important in:

Market data

Gaming

Realtime collaboration

7Ô∏è‚É£ Reliability & Reconnection
SSE

Advantages:

Automatic reconnection

Last-Event-ID header support

Simple resume mechanism

Great for:

News feeds

Notifications

Event logs

WebSockets

Must implement reconnection manually

Must reauthenticate

Must resubscribe to channels

More work but more control

8Ô∏è‚É£ Security

Both use TLS:

HTTPS for SSE

WSS for WebSockets

WebSockets:

Can be more complex behind corporate proxies

Some legacy firewalls block WS upgrade

SSE:

Works almost everywhere HTTP works

9Ô∏è‚É£ Resource Usage Comparison
Factor	SSE	WebSockets
Memory per connection	Moderate	Slightly lower
CPU overhead	Higher under load	More efficient
Binary support	No	Yes
Duplex	No	Yes
Proxy friendliness	High	Medium
Complexity	Low	Higher
üîü When Interviewers Expect You to Choose Each
Choose SSE When:

One-way streaming

Moderate frequency

Simplicity matters

Automatic retry is helpful

Corporate network compatibility needed

Examples:

Notification service

Live news feed

CI/CD build logs

Portfolio tracker

Choose WebSockets When:

Bidirectional communication

High-frequency updates

Binary data needed

Tight latency requirements

Fine-grained control required

Examples:

Trading systems

Multiplayer games

Collaborative editors

Chat systems

IoT telemetry

1Ô∏è‚É£1Ô∏è‚É£ Architecture-Level Comparison
SSE Architecture
Browser
   ‚Üì (HTTP)
Load Balancer
   ‚Üì
SSE Servers
   ‚Üì
Message Broker


Simpler but less flexible.

WebSocket Architecture
Browser
   ‚Üì (WS)
Load Balancer (sticky)
   ‚Üì
WS Servers
   ‚Üì
Redis/Kafka
   ‚Üì
Services


More complex but scalable.

1Ô∏è‚É£2Ô∏è‚É£ Edge Cases Interviewers May Ask
‚ùì What happens if client loses connection?

SSE:

Auto reconnect

Sends Last-Event-ID

WebSocket:

App must detect

Reconnect

Resubscribe

‚ùì How do you scale to 10M connections?

You discuss:

Horizontal sharding

Event partitioning

Kernel tuning

Epoll / non-blocking IO

Load balancer tuning

Connection multiplexing

Possibly HTTP/2 (for SSE)

1Ô∏è‚É£3Ô∏è‚É£ Modern Reality Check

For serious real-time systems today:

Most companies default to WebSockets.

SSE is used in:

Simpler push systems

Internal dashboards

Lightweight streaming APIs

1Ô∏è‚É£4Ô∏è‚É£ Interview-Ready Summary Statement

If asked:

‚ÄúWhich would you choose?‚Äù

You answer:

If one-way, moderate frequency, and simplicity ‚Üí SSE.

If high throughput, bidirectional, low latency ‚Üí WebSockets.

For trading or collaborative systems ‚Üí WebSockets.

For notification feeds ‚Üí SSE.

1Ô∏è‚É£5Ô∏è‚É£ Deep Insight (High-Level System Design Edge)

The protocol choice is rarely the hardest problem.

The real problems are:

State synchronization

Message ordering

Backpressure

Idempotency

Horizontal scaling

Failure recovery

Strong candidates shift the discussion there.